# Конфигурационный файл Sydr-fuzz

* TOC
{:toc}

Конфигурационный файл (`sydr-fuzz.toml`) используется для задания опций
фаззера и Sydr. Все пути задаются либо абсолютно, либо относительно
директории, в которой расположен конфигурационный файл. Для настройки запуска
различных инструментов в этом файле указываются таблицы `[sydr]`, `[libfuzzer]`,
`[aflplusplus]` (или список таблиц `[[aflplusplus]]`), `[honggfuzz]`, `[atheris]`,
`[jazzer]`, `[jazzer_js]`, `[sharpfuzz]`, `[luzer]`, и `[cov]`. Конфигурационный файл задает
настройки для анализа конкретной фаззинг-цели, поэтому он не может одновременно содержать
таблицы для несовместимых инструментов (на примере ниже для краткости приведены сразу все таблицы).
Таблицы `[atheris]`, `[jazzer]` и `[jazzer_js]` несовместимы с какой-либо
другой таблицей,
таблица `[sharpfuzz]` и `[luzer]` может одновременно находиться в файле только с таблицей `[cov]`,
причем эта таблица должна быть указана в одном из двух специальных форматов (на примере
ниже приведены все таблицы для краткости). К тому же таблица `[cov]` не может
находиться в файле без других таблиц.

```toml
exit-on-time = 7200

[sydr]
args = "-j 4"
target = "/target_sydr @@"
jobs = 3

[aflplusplus]
args = "-t 5000 -i /corpus"
target = "/target_afl @@"
jobs = 6

[libfuzzer]
path = "/target_fuzzer"
args = "-dict=/json.dict -jobs=6 /corpus"

[honggfuzz]
args = "-t 5 -i /corpus"
target = "/target_hf ___FILE___"
jobs = 6

[atheris]
path = "/target.py"
args = "/corpus -jobs=4 -workers=4"

[jazzer]
args = "--cp=/out --asan -jobs=4 /corpus"
target_class = "ExampleFuzzerNative"

[jazzer_js]
path = "/target.js"
args = "-i=mylib /corpus -- -jobs=4 -workers=4"

[luzer]
path = "/target.lua"
args = "-only_ascii=1 /corpus"

[sharpfuzz]
args = "-i /corpus -t 10000"
target = "/target.dll"
casr_bin = "/casr_target.dll"
dotnet = "/usr/bin/dotnet"
jobs = 2

# Для Sharpfuzz с инструментом AltCover.
[cov]
build_dir = "/fuzz"
tool_path = "/usr/bin/altcover"

# Для Sharpfuzz с инструментом minicover.
[cov]
target = "/fuzz/Program.cs"
source = "/source"
build_dir = "/fuzz"
tool_path = "/usr/bin/minicover"
use_minicover = true

# Для инструментированного C/C++/Rust/Go кода.
[cov]
target = "/instrumented_target @@"
```

**exit-on-time** - опциональный параметр указывает время в секундах. Если в
течение этого времени покрытие не растет, фаззинг автоматически завершается.

**out** - опциональный параметр указывает путь до выходной директории с
проектом, где содержатся артефакты и результаты работы фаззинга. Если не
указывать эту опцию, то проект создастся в текущей директории с именем
`<CONFIG>-out`. Данный параметр дублирует аргумент командной строки `--output`,
который считается более приоритетным, чем значение из конфигурационного файла.

### Sydr

```toml
[sydr]
args = "-j 4"
target = "/target_sydr @@"
jobs = 3
timeout = 1000
cache = true
optimistic = true
fuzzmem = false
wait_jobs = false
solving_limit = false
symaddr = 20
fuzzer_dir = "/path/to/fuzzer/dir"
output_dir = "/path/to/output/dir"
minimize_sydr_inputs = true
[sydr.env]
    CLASSIC_ENVVAR = "XXX"
```

Таблица `[sydr]` может содержать следующие параметры:

**args** - аргументы Sydr. Опции `--sym-file` и `--log-file` задаются
автоматически, их указывать не надо.

**target** - строка запуска обертки для Sydr. Вместо имени символьного входного
файла следует использовать `@@`.

**jobs** - число процессов Sydr для запуска (по умолчанию 1). Всего запускается
**jobs** процессов Sydr в `-j` (задается в **args**) потоков каждый.

**timeout** - тайм-аут в секундах, по истечении которого процесс Sydr будет
остановлен. Если параметр не указан, выставляется 20 минут (1200 секунд).

**cache** - булевый параметр (по умолчанию включен), который включает кэш
инвертированных переходов.

**optimistic** - булевый параметр (по умолчанию включен), который включает
оптимистичные решения.

**fuzzmem** - булевый параметр (по умолчанию включен), который включает режим
фаззинга символьных адресов.

**wait_jobs** - булевый параметр (по умолчанию включен), который включает
приостановление построения предиката пути, когда набрано достаточно
необработанных запросов к математическому решателю.

**solving_limit** - булевый параметр (по умолчанию включен), который включает 60
секундный тайм-аут на суммарное время, проведенное в решателе.

**symaddr** - целочисленный параметр, который включает режим обработки символьных
адресов раз в N запусков Sydr (по умолчанию N = 25). Чтобы выключить этот режим,
необходимо указать N = 0.

**fuzzer_dir** - путь до рабочей директории фаззера (только в режиме
присоединения Sydr к внешнему фаззеру). В случае AFL++ - worker-директория, в
случае libFuzzer - его рабочая директория.

**output_dir** - путь до выходной директории для Sydr (только в режиме
присоединения Sydr к внешнему фаззеру). Здесь будут появляться сгенерированные
инструментом Sydr файлы с входными данными.

**minimize_sydr_inputs** - булевый параметр (по умолчанию включен), который
включает минимизацию входных файлов, сгенерированных инструментом Sydr (для
AFL++ и Honggfuzz).

**[sydr.env]** - таблица, содержащая значения переменных окружения, которые будут
выставлены для каждого запускаемого процесса Sydr. Каждая строка таблицы задаёт
строковую переменную, имя которой совпадает с именем соответствующей переменной окружения.
Значения переменных окружения можно задавать также в системных переменных окружения.
При этом значения, заданные в файле конфигурации, более приоритетны, чем
значения, заданные в системных переменных окружения.

### AFL++

```toml
[aflplusplus]
path = "/afl"
args = "-t 5000 -i /corpus"
target = "/target_afl @@"
cmin = 8
jobs = 6
foreign = ["/path/to/foreign_fuzzer/syncdir"]
[aflplusplus.env]
    AFL_PRINT_FILENAMES = "1"
    AFL_MAP_SIZE = "10000000"
```

Таблица `[aflplusplus]` может содержать следующие параметры:

**args** - аргументы AFL++. Необходимым аргументом является опция `-i` для
указания входного корпуса. Дополнительно можно
указать опции для инструментации (`-Q`, `-O` для бинарной инструментации),
тайм-аутов (`-t 5000` миллисекунд) и другие.

**target** - строка запуска обертки для AFL++. Вместо имени входного файла
следует использовать `@@`. Если обертка читает входные данные со стандартного
потока ввода, то `@@` указывать не нужно.

**cmin** - булевый/целочисленный параметр (по умолчанию `true`), который включает минимизацию
входного корпуса при старте гибридного фаззинга. Этот параметр также может использоваться для
указания числа потоков для параллельного запуска утилиты `afl-cmin`. Если параметр установлен
в `true`, то используется половина всех доступных ядер на машине. Если указанное число потоков
больше, чем доступно ядер на машине, то для распараллеливания `afl-cmin` используются все ядра.
Если параметр выключен (`false` или `0`), то минимизация корпуса перед запуском гибридного
фаззинга не производится, а при вызове команды `cmin` используется половина всех доступных ядер.

**jobs** - число процессов AFL++ для запуска (по умолчанию 1).

Для таблицы `[aflplusplus]` запуск нескольких
процессов AFL++ осуществляется автоматически в соответствии с
[рекомендациями](https://github.com/AFLplusplus/AFLplusplus/blob/stable/docs/fuzzing_in_depth.md#c-using-multiple-cores):
запускается один основной фаззер (`afl_main-worker`) и `jobs-1` второстепенных процессов
(`afl_s<i>-worker`), каждый второстепенный фаззер имеет свой набор
генерируемых автоматически опций с настройками фаззинга.

Одновременно нельзя запустить более 64 процессов AFL++, так как это очень
неэффективная стратегия для гибридного фаззинга
([объяснение](https://github.com/AFLplusplus/AFLplusplus/blob/stable/docs/fuzzing_in_depth.md#c-using-multiple-cores)).

**path** - путь до AFL++ и его утилит. Параметр не обязателен, если путь
добавлен в `$PATH` (в докере `sydr/ubuntu20.04-sydr-fuzz` уже добавлен).

**foreign** - директории с очередью сторонних фаззеров (опция `-F` AFL++). Параметр может быть
строкой или массивом строк. Путь до директорий с очередью сторонних фаззеров может быть
указан относительно конфигурационного файла. Синхронизация со сторонними фаззерами доступна только
для главного процесса AFL++ (-M), поэтому при указании **foreign** требуется несколько запущенных
экземпляров AFL++ (**jobs** > 1).

**[aflplusplus.env]** - таблица, содержащая значения переменных окружения, которые будут
выставлены для каждого запускаемого процесса AFL++. Каждая строка таблицы задаёт
строковую переменную, имя которой совпадает с именем соответствующей переменной окружения.

Для настройки AFL++ можно использовать различные переменные окружения. Переменные
`AFL_SKIP_CPUFREQ=1`, `AFL_NO_UI=1`, `AFL_PRINT_FILENAMES`, `AFL_AUTORESUME`,
`AFL_MAP_SIZE=65536` выставляются автоматически по необходимости. `AFL_MAP_SIZE`
можно задать своим значением, однако это в большинстве случаев не требуется, т.к.
afl-fuzz определяет размер битовой карты автоматически. Переменная
`AFL_PRINT_FILENAMES=1` позволяет во время минимизации следить, какой файл
обрабатывается в данный момент. Это удобно, когда в корпусе находятся входные
файлы, приводящие к аварийному завершению, что приводит к ошибке работы
минимизации. При помощи `AFL_PRINT_FILENAMES=1` можно будет найти такие файлы
и удалить их. Также для тяжелых фаззинг целей можно выставить большое
значение переменной `AFL_FORKSRV_INIT_TMOUT`, отвечающей за максимальное время
инициализации форк-сервера AFL++, а также выставить переменную `AFL_MAP_SIZE=10000000`.
Для лучшего взаимодействия AFL++ и Sydr можно уменьшить интервал
синхронизации `AFL_SYNC_TIME` (указывается в минутах, по умолчанию 30 минут).
Также могут быть полезными переменные `AFL_DISABLE_TRIM`, `AFL_SHUFFLE_QUEUE`,
`AFL_NO_AFFINITY`.

По умолчанию задаются также переменные среды

`ASAN_OPTIONS="hard_rss_limit_mb=2048,abort_on_error=1,detect_leaks=0,`

`malloc_context_size=0,symbolize=0,allocator_may_return_null=1"`

`UBSAN_OPTIONS="halt_on_error=0,abort_on_error=0,malloc_context_size=0,`

`allocator_may_return_null=1"`

Значения по умолчанию можно менять путем переопределения их в таблице `[aflplusplus.env]` или в системных
переменных окружения.
При этом наибольший приоритет имеют значения, заданные в файле конфигурации; средний приоритет имеют
значения, заданные в системных переменных окружения; низший приоритет имеют значения по умолчанию.
Полный список переменных окружения приведен
[здесь](https://github.com/AFLplusplus/AFLplusplus/blob/stable/docs/env_variables.md).

Значение некоторых параметров `ASAN_OPTIONS`:

**hard_rss_limit_mb** - задает ограничение памяти анализируемого приложения в Мб (по
умолчанию 2 Гб). Чтобы снять ограничение памяти, можно указать 0. Данная опция
помогает Casr обнаруживать oom и отличать аварийное завершение от oom на шаге
`sydr-fuzz casr`. Однако AFL++ не поддерживает ограничение памяти через
`ASAN_OPTIONS`. Для обработки oom в AFL++ рекомендуется выключить swap. Тогда
программа будет убиваться системным OOM Killer.

**detect_leaks** - булевый параметр (по умолчанию выключен), который включает
режим фаззинга, при котором срабатывания leak-санитайзера считаются аварийными
завершениями.

**allocator_may_return_null** - булевый параметр (по умолчанию включен), который
разрешает аллокатору возвращать нулевой указатель.

Задание параметров `halt_on_error=1,abort_on_error=1` для `UBSAN_OPTIONS`
включает режим фаззинга, при котором срабатывания ubsan-санитайзера приводят
к аварийным завершениям.

Конфигурация AFL++ может быть задана как с помощью одной таблицы `[aflplusplus]`,
так и с помощью списка таблиц `[[aflplusplus]]`. В первом случае все параметры,
заданные в таблице, применяются ко всем процессам AFL++. Во втором случае первая
таблица является основной и задаёт параметры для основного (main) процесса AFL++ и некоторого
числа дополнительных (secondary) процессов, а каждая следующая таблица позволяет запустить
определённое число дополнительных (secondary) процессов фаззера со своими параметрами.

Пример с несколькими таблицами:

```toml
[[aflplusplus]]
path = "/afl"
args = "-t 5000 -i /corpus"
target = "/target_afl @@"
cmin = true
jobs = 6
[aflplusplus.env]
    AFL_PRINT_FILENAMES = "1"

[[aflplusplus]]
args = "-t 10000"
target = "/target_afl_other @@"
jobs = 2
[aflplusplus.env]
    AFL_MAP_SIZE = "10000000"
```

Задание различных опций для дополнительных процессов фаззера
может быть полезно при использовании инструментации [CmpLog](https://github.com/AFLplusplus/AFLplusplus/blob/stable/instrumentation/README.cmplog.md) ([RedQueen](https://github.com/RUB-SysSec/redqueen))
или [laf-intel](https://github.com/AFLplusplus/AFLplusplus/blob/stable/instrumentation/README.laf-intel.md) (COMPCOV).

Пример с несколькими таблицами для CmpLog:

```toml
[[aflplusplus]]
args = "-i /corpus -t 2000"
target = "/target_afl @@"
jobs = 4

[[aflplusplus]]
args = "-t 2000 -c /target_afl_cmplog -m none"
target = "/target_afl @@"
jobs = 2
```

Первая таблица списка `[[aflplusplus]]` может содержать все перечисленные выше
параметры. Каждая дополнительная таблица списка `[[aflplusplus]]` может содержать
все перечисленные выше параметры, кроме **path** и **cmin** (эти параметры задаются
только для первой таблицы списка).

При использовании списка `[[aflplusplus]]` директории для входного корпуса
(опция `-i` в **args**) должны совпадать во всех таблицах (кроме того, достаточно
задать опцию только для первой таблицы).

Для первой таблицы списка запускается один основной фаззер (`afl_main-worker`)
и `jobs-1` второстепенных процессов (`afl_s<i>-worker`), каждый второстепенный
фаззер имеет свой набор генерируемых автоматически опций с настройками фаззинга.
Для всех остальных таблиц списка `[[aflplusplus]]` производится запуск `jobs`
второстепенных процессов (`afl_s<i>-worker`), каждый второстепенный фаззер
имеет одинаковый набор заданных в этой таблице опций. Опция **foreign** может
быть указана только для главной таблицы.

### libFuzzer

```toml
[libfuzzer]
path = "/target_fuzzer"
args = "-dict=/json.dict -jobs=6 /corpus"
cmin = true
set_cover_merge = true
proto_packer_path = "/packer"
use_ft_coverage = false
[libfuzzer.env]
    ASAN_OPTIONS = "allocator_may_return_null=0"
```

Таблица `[libfuzzer]` может содержать следующие параметры:

**path** - путь до libFuzzer обертки.

**args** - аргументы libFuzzer. В аргументах могут быть указаны входные
директории с корпусами. Выходная директория с корпусом автоматически создается в
каталоге с проектом (и подставляется в аргументы libFuzzer). В выходной корпус
будут минимизированы все входные корпуса. Число процессов libFuzzer можно
контролировать через опцию `-jobs=N`,
которая указывает на то, что должно быть выполнено N запусков фаззинга до конца
(пока не найден баг или исчерпан лимит времени/числа итераций). Запуски фаззинга
распределяются между несколькими процессами libFuzzer (по умолчанию используется
не больше половины доступных ядер), число которых можно задать через
`-workers=N`. Если цель для фаззинга аварийно завершается, имеет смысл
использовать опции `-jobs=M -workers=N`, где N - число процессов libFuzzer, а
M - число аварийных завершений, зависаний и oom, по достижению которого фаззинг
будет завершен. Подробное описание опций libFuzzer можно найти в его
[документации](https://www.llvm.org/docs/LibFuzzer.html).

**cmin** - булевый/целочисленный параметр (по умолчанию `true`), который включает
минимизацию входных корпусов в выходной корпус проекта. Если параметр выключен,
то происходит просто копирование входных корпусов в выходной корпус проекта.
Минимизацию корпуса, например, можно выключить, когда libFuzzer не справляется
минимизировать корпус.

**set_cover_merge** - булевый параметр (по умолчанию выключен), который
позволяет использовать для минимизации опцию libFuzzer `set_cover_merge`. Если
параметр выключен, для минимизации используется опция `merge`.

**proto_packer_path** - путь до packer-утилиты для гибридного фаззинга структурированных данных при
помощи libFuzzer с [LPM](https://github.com/google/libprotobuf-mutator) в паре с Sydr.
Утилита выполняет двустороннюю конвертацию между целевым форматом входных данных и protobuf-сообщениями.
При наличии данного параметра в конфигурационном файле обязательно присутствие таблицы `[sydr]`.

**use_ft_coverage** - булевый параметр (по умолчанию выключен), который позволяет
учитывать метрику features (ft:) libFuzzer'а для отслеживания прироста покрытия. По
умолчанию на факт прироста покрытия влияет только метрика coverage (cov:). При фаззинге
Go-приложений (go-fuzz) метрика coverage отсутсвует, поэтому feature используется всегда.

**[libfuzzer.env]** - таблица, содержащая значения переменных окружения, которые будут
выставлены для каждого запускаемого процесса libFuzzer. Каждая строка таблицы задаёт
строковую переменную, имя которой совпадает с именем соответствующей переменной окружения.

По умолчанию задаётся переменная среды `ASAN_OPTIONS="allocator_may_return_null=1"`.

Значения по умолчанию можно менять путем переопределения их в таблице `[libfuzzer.env]` или в системных
переменных окружения. Значения опций `hard_rss_limit_mb` и `detect_leaks` нужно задавать только через
соответствующие аргументы libFuzzer: `-rss_limit_mb` и `-detect_leaks`.
При этом наибольший приоритет имеют значения, заданные в файле конфигурации; средний приоритет имеют
значения, заданные в системных переменных окружения; низший приоритет имеют значения по умолчанию.

### Honggfuzz

```toml
[honggfuzz]
path = "/honggfuzz"
args = "-t 5 -i /corpus"
target = "/target_hf ___FILE___"
cmin = true
jobs = 6
foreign = "/path/to/foreign_fuzzer/syncdir"
libfuzzer_merge_target = "/path/to/libfuzzer/target"
[honggfuzz.env]
    ASAN_OPTIONS = "allocator_may_return_null=0"
```

Таблица `[honggfuzz]` может содержать следующие параметры:

**path** - путь до исполняемого файла Honggfuzz. Параметр не обязателен, если путь
добавлен в `$PATH` (в докере `sydr/ubuntu20.04-sydr-fuzz` уже добавлен).

**args** - аргументы Honggfuzz. Необходимым аргументом является опция `-i` для
указания входного корпуса. Дополнительно можно указать опции для тайм-аутов (`-t 5` секунд),
словарей (`--dict path_to_file`) и инструментации `-P|--persistent`, `-x|--noinst`,
`-z|--instrument` (необязательны, т.к. режимы инструментации определяются фаззером
автоматически).

**target** - строка запуска обертки для Honggfuzz. Вместо имени входного файла
следует использовать `___FILE___`. Если обертка читает входные данные со стандартного
потока ввода, то вместо `___FILE___` нужно добавить опцию `--stdin_input` в аргументы
**args** (необязательно, фаззер сам может определить источник входных данных).

**cmin** - булевый параметр (по умолчанию `true`), который включает минимизацию
входного корпуса при старте гибридного фаззинга. Если параметр выключен,
то минимизация корпуса перед запуском гибридного фаззинга не производится.

**jobs** - число процессов Honggfuzz для запуска (по умолчанию 1).

**foreign** - директория с очередью сторонних фаззеров (опция `--dynamic_input` Honggfuzz). Параметр
является строкой. Путь до директории с очередью сторонних фаззеров может быть указан относительно
конфигурационного файла. Honggfuzz поддерживает только одну директорию для синхронизации со сторонними
инструментами, поэтому параметр `foreign` может быть использован только если Honggfuzz запускается
без синхронизации с Sydr.

**libfuzzer_merge_target** - путь до libFuzzer обертки, которая будет использоваться для минимизации
инпутов Sydr при синхронизации с фаззером. По умолчанию минимизация происходит с помощью Honggfuzz
(--minimize), однако если данный способ работает слишком медленно, то параметр позволяет использовать
более быстрый libFuzzer-merge для минимизации. Также, минимизацию инпутов Sydr можно отключить
с помощью параметра [sydr] `minimize_sydr_inputs`.

**[honggfuzz.env]** - таблица, содержащая значения переменных окружения, которые будут
выставлены для Honggfuzz. Каждая строка таблицы задаёт строковую переменную, имя которой совпадает
с именем соответствующей переменной окружения. Honggfuzz по умолчанию задает переменные `ASAN_OPTIONS`,
`UBSAN_OPTIONS`, `MSAN_OPTIONS` и `LSAN_OPTIONS` со значением `symbolize=1:detect_leaks=0:`
`disable_coredump=0:detect_odr_violation=0:allocator_may_return_null=1:allow_user_segv_handler=1:`
`handle_segv=0:handle_sigbus=0:handle_abort=0:handle_sigill=0:handle_sigfpe=0:abort_on_error=1`.
Значения по умолчанию можно менять путем переопределения их в таблице `[honggfuzz.env]` или в системных
переменных окружения.

### Atheris

```toml
[atheris]
path = "/target_fuzzer"
args = "-dict=/json.dict -jobs=6 /corpus"
cmin = true
set_cover_merge = true
use_ft_coverage = false
ld_preload = false
[atheris.env]
    ASAN_OPTIONS = "allocator_may_return_null=0"
```

Таблица `[atheris]`, помимо всех параметров таблицы `[libfuzzer]`, содержит один
дополнительный параметр:

**ld_preload** - булевый параметр (по умолчанию включен), который позволяет при
запуске Python-кода для фаззинга, сбора покрытия или анализа аварийных
завершений устанавливать переменную среды `LD_PRELOAD` равной пути до библиотеки
`asan_with_fuzzer.so`, необходимой при работе с кодом, имеющим расширения на
языках C/C++, для их инструментации.

Для Atheris по умолчанию задаётся переменная среды

`ASAN_OPTIONS="hard_rss_limit_mb=0,abort_on_error=1,detect_leaks=0,malloc_context_size=0,`

`allocator_may_return_null=1"`

Значения по умолчанию можно менять путем переопределения их в таблице `[atheris.env]` или в системных
переменных окружения.
При этом наибольший приоритет имеют значения, заданные в файле конфигурации; средний приоритет имеют
значения, заданные в системных переменных окружения; низший приоритет имеют значения по умолчанию.

### Jazzer

```toml
[jazzer]
path = "/path/to/jazzer"
agent_path = "/path/to/jazzer_standalone_deploy.jar"
args = "--cp=/path/to/java/classes/ --asan -jobs=6 /corpus"
target_class = "TargetClass"
cmin = true
set_cover_merge = true
use_ft_coverage = false
java = "/path/to/jvm/launcher/java"
jacocolib = "/path/to/jacoco/lib"
jacoco_args = "excludes=com.code_intelligence.jazzer.*\\:com.sun.tools.attach.VirtualMachine"
[jazzer.env]
    LD_LIBRARY_PATH = "/path/to/native/libraries/"
```

**path** - путь до бинарного файла jazzer (по умолчанию: `/usr/local/bin/jazzer`).

**agent_path** - путь до jazzer API (по умолчанию: `/usr/local/lib/jazzer_standalone_deploy.jar`).

**args** - аргументы jazzer и libFuzzer.

**target_class** - название Java класса с методом `fuzzerTestOneInput`.

**cmin** и **set_cover_merge** - как у libFuzzer.

**java** - путь до Java лаунчера (по умолчанию берется из `PATH`).

**jacocolib** - путь до jar файлов библиотеки jacoco (необходимо для сбора
покрытия, по умолчанию: `/usr/local/lib/jacoco/lib`).

**jacoco_args** - дополнительные аргументы для библиотеки JaCoCo, которые передаются через опцию
`--additional_jvm_args`. Параметр ожидает строку формата "arg1=value1,arg2=value2". С помощью данного
параметра можно указать аргумент `excludes`, который позволяет избежать ошибок с одинаковыми именами
разных классов при сборе покрытия. Аргумент `destfile` всегда задается автоматически, поэтому он
не может быть указан в данном параметре.

Jazzer поддерживает фаззинг C/C++ библиотек, загруженных JVM, например, через `System.load()`.
Иногда требуется добавить пути, в которых будет производится поиск разделяемых
библиотек. Сделать это можно с помощью таблицы `[jazzer.env]`, указав значение
переменной среды `LD_LIBRARY_PATH`.

Для Jazzer по умолчанию задаётся переменная среды

`ASAN_OPTIONS="hard_rss_limit_mb=0,abort_on_error=1,detect_leaks=0,malloc_context_size=0,`

`allocator_may_return_null=1"`

Значения по умолчанию можно менять путем переопределения их в таблице `[jazzer.env]` или в системных
переменных окружения.
При этом наибольший приоритет имеют значения, заданные в файле конфигурации; средний приоритет имеют
значения, заданные в системных переменных окружения; низший приоритет имеют значения по умолчанию.

### Jazzer.js

```toml
[jazzer_js]
path = "/target_fuzzer"
args = "-i=target_lib /corpus -- -dict=/json.dict -jobs=6"
cmin = true
set_cover_merge = true
use_ft_coverage = false
ld_preload = false
[jazzer_js.env]
    ASAN_OPTIONS = "allocator_may_return_null=0"
```

**path** - путь до Jazzer.js обертки.

**args** - аргументы Jazzer.js и libFuzzer. Сначала перечисляются аргументы
Jazzer.js, затем ставится разделитель "--", далее перечисляются аргументы
libFuzzer.

**ld_preload** - булевый параметр (по умолчанию включен), который позволяет при
запуске JavaScript-кода для фаззинга, сбора покрытия или анализа аварийных
завершений устанавливать переменную среды `LD_PRELOAD` равной пути до библиотеки
`libclang_rt.asan-x86_64.so`, необходимой при работе с кодом, имеющим расширения на
языках C/C++, для их инструментации.

Для Jazzer.js по умолчанию задаётся переменная среды

`ASAN_OPTIONS="hard_rss_limit_mb=0,abort_on_error=1,detect_leaks=0,malloc_context_size=0,`

`allocator_may_return_null=1"`

Значения по умолчанию можно менять путем переопределения их в таблице `[jazzer_js.env]` или в системных
переменных окружения.
При этом наибольший приоритет имеют значения, заданные в файле конфигурации; средний приоритет имеют
значения, заданные в системных переменных окружения; низший приоритет имеют значения по умолчанию.

### luzer

```toml
[luzer]
path = "/target.lua"
args = "-only_ascii=1 /corpus"
jobs = 10
```

**path** - путь до обертки luzer.

**jobs** - количество найденных luzer аварийных завершений (по умолчанию 1). Параллельное фаззинг-тестирование не поддерживается для luzer, поэтому запуск происходит последовательно.

**args** - аргументы luzer и libFuzzer.

### Sharpfuzz

```toml
[sharpfuzz]
path = "/afl"
args = "-t 5000 -i /corpus"
target = "/target_sharpfuzz.dll"
casr_bin = "/casr_target_sharpfuzz.dll"
dotnet = "/usr/bin/dotnet"
cmin = 8
jobs = 6
[sharpfuzz.env]
    AFL_PRINT_FILENAMES = "1"
```

Таблица `[sharpfuzz]` может содержать следующие параметры:

**args** - аргументы для AFL++ (так как Sharpfuzz использует AFL++ для фаззинга целей).
Необходимым аргументом является опция `-i` для указания входного корпуса. Дополнительно можно
указать опции для инструментации (`-Q`, `-O` для бинарной инструментации),
тайм-аутов (`-t 5000` миллисекунд) и другие.

**target** - строка запуска обертки. В случае фаззинга C#, это должен быть модуль .dll.
Вместо имени входного файла следует использовать `@@`.
Если обертка читает входные данные со стандартного потока ввода, то `@@` указывать не нужно.

**cmin** - булевый/целочисленный параметр (по умолчанию `true`), который включает минимизацию
входного корпуса при старте гибридного фаззинга. Этот параметр также может использоваться для
указания числа потоков для параллельного запуска утилиты `afl-cmin`. Если параметр установлен
в `true`, то используется половина всех доступных ядер на машине. Если указанное число потоков
больше, чем доступно ядер на машине, то для распараллеливания `afl-cmin` используются все ядра.
Если параметр выключен (`false` или `0`), то минимизация корпуса перед запуском гибридного
фаззинга не производится, а при вызове команды `cmin` используется половина всех доступных ядер.

**jobs** - число процессов AFL++ для запуска (по умолчанию 1). Примечания по данному параметру можно
посмотреть в описании параметра `jobs` для AFL++.

**path** - путь до AFL++ и его утилит. Параметр не обязателен, если путь
добавлен в `$PATH` (в докере `sydr/ubuntu20.04-sydr-fuzz` уже добавлен).

**casr_bin** - путь до модуля .dll обертки фаззинг цели без инструментации Sharpfuzz. Данный
аргумент обязателен, если будет использоваться команда `sydr-fuzz casr` для анализа аварийных
завершений. Если проект собирался с помощью `dotnet publish -o bin`, то можно указать модуль,
лежащий внутри директории `bin/Release`, либо можно скопировать проект в другую директорию и
собрать без инструментации Sharpfuzz.

**dotnet** - путь до клиента dotnet. Параметр не обязателен, если путь
добавлен в `$PATH` (в докере `sydr/ubuntu20.04-sydr-fuzz` уже добавлен).

**[sharpfuzz.env]** - В данной таблице переменные среды задаются аналогично таблице
`[aflplusplus.env]`, но с ограничениями. Переменные среды `ASAN_OPTIONS` и `UBSAN_OPTIONS`
в Sharpfuzz не используются, переменная среды `AFL_MAP_SIZE` выставлена по умолчанию равной
`10000000` (не рекомендуется выставлять ее значением, меньшим `5000000`, так как могут возникнуть
ошибки запуска), а переменная `AFL_I_DONT_CARE_ABOUT_MISSING_CRASHES` выставлена равной `1` в
силу особенностей фаззинга C# кода.

### Coverage (для C#-кода)

Для `minicover`:
```toml
[cov]
build_dir = "/fuzz"
target = "/fuzz/Program.cs"
source = "/source"
tool_path = "/usr/bin/minicover"
use_minicover = true
```

Для `AltCover`:
```toml
[cov]
build_dir = "/fuzz"
tool_path = "/usr/bin/altcover"
use_minicover = false
```

Таблица `[cov]` содержит следующие параметры:

**target** - путь до файла с кодом обертки для фаззинга (для `minicover`).

**source** - путь до директории с исходным кодом проекта (для `minicover`).

**build_dir** - путь до директории, где собирается программа (в этой директории
должны лежать фаззинг-обертка и конфигурационный .csproj файл).

**use_minicover** - булевый параметр (по умолчанию `false`), который указывает, какой инструмент
будет использоваться для сбора покрытия (`true` - `minicover`, `false` - `AltCover`).

**tool_path** - путь до инструмента сбора покрытия `minicover` или `AltCover`. Если он был установлен
как глобальный .NET инструмент, то он будет по умолчанию находиться в `$HOME/.dotnet/tools`.
Параметр не обязателен, если путь добавлен в `$PATH` (в докере `sydr/ubuntu20.04-sydr-fuzz` уже добавлен).

**proto_to_native_cov** - булевый параметр (по умолчанию `false`), который указывает, нужно ли конвертировать во время сбора покрытия результирующий корпус. Используется только при указанном в таблице `libfuzzer` параметре `proto_packer_path`.

Таблица **[cov.env]** в случае C#-кода не используется, так как переменные окружения для сбора покрытия не
используются в `minicover` и `AltCover`.

### Coverage (для инструментированного C/C++/Rust/Go-кода)

```toml
[cov]
target = "/instrumented_target @@"
[cov.env]
    CLASSIC_ENVVAR = "XXX"
```

Таблица `[cov]` содержит следующие параметры:

**target** - строка запуска инструментированного для сбора покрытия целевого
исполняемого файла. При сборке исполняемого файла следует использовать флаги:
`-fprofile-instr-generate -fcoverage-mapping`.

**[cov.env]** - таблица, содержащая значения переменных окружения, которые будут
выставлены при сборе покрытия. Каждая строка таблицы задаёт строковую переменную,
имя которой совпадает с именем соответствующей переменной окружения.

Значения переменных окружения можно задавать также в системных переменных окружения.
При этом значения, заданные в файле конфигурации, более приоритетны, чем
значения, заданные в системных переменных окружения.
